/**
* The MIT License (MIT)
* Copyright (c) 2016 Shopify Inc.
* 
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
* 
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
* 
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
* DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
* OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
* OR OTHER DEALINGS IN THE SOFTWARE.
* 
* 
* Version: 0.4.0 Commit: aaab874
**/'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = generateSchemaModules;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _lodash = require('lodash.kebabcase');

var _lodash2 = _interopRequireDefault(_lodash);

var _babelGenerator = require('babel-generator');

var _babelGenerator2 = _interopRequireDefault(_babelGenerator);

var _simplifyType = require('./simplify-type');

var _simplifyType2 = _interopRequireDefault(_simplifyType);

var _typeTemplate = require('./type-template');

var _typeTemplate2 = _interopRequireDefault(_typeTemplate);

var _bundleTemplate = require('./bundle-template');

var _bundleTemplate2 = _interopRequireDefault(_bundleTemplate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function yieldTypes(schema) {
  return schema.types;
}

function filterTypes(whitelist) {
  return function (types) {
    if (!whitelist) {
      return types;
    }

    return types.filter(simplifiedType => {
      return whitelist.includes(simplifiedType.name);
    });
  };
}

function simplifyTypes(whitelist) {
  return function (types) {
    return types.map(type => (0, _simplifyType2.default)(type, whitelist));
  };
}

function filenameForType(type) {
  return _path2.default.join('types', `${ (0, _lodash2.default)(type.name) }.js`);
}

function mapTypesToFiles(simplifiedTypes) {
  return simplifiedTypes.map(simplifiedType => {
    return {
      name: simplifiedType.name,
      body: (0, _babelGenerator2.default)((0, _typeTemplate2.default)(simplifiedType)).code,
      path: filenameForType(simplifiedType)
    };
  });
}

function injectBundle(rootTypeNames, bundleName) {
  return function (typeFileMaps) {
    const bundleAst = (0, _bundleTemplate2.default)(rootTypeNames, typeFileMaps, bundleName.replace(' ', ''));
    const bundle = (0, _babelGenerator2.default)(bundleAst).code;

    typeFileMaps.push({
      body: bundle,
      path: `${ (0, _lodash2.default)(bundleName) }.js`
    });

    return typeFileMaps;
  };
}

function extractRootTypeNames({ queryType, mutationType, subscriptionType }) {
  return {
    queryTypeName: queryType ? queryType.name : null,
    mutationTypeName: mutationType ? mutationType.name : null,
    subscriptionTypeName: subscriptionType ? subscriptionType.name : null
  };
}

function flow(arg, functions) {
  return functions.reduce((acc, fn) => fn(acc), arg);
}

function generateSchemaModules(introspectionResponse, bundleName, whitelist) {
  const schema = introspectionResponse.data.__schema;

  return flow(schema, [yieldTypes, filterTypes(whitelist), simplifyTypes(whitelist), mapTypesToFiles, injectBundle(extractRootTypeNames(schema), bundleName)]);
}