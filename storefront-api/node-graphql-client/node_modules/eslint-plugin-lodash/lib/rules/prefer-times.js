/**
 * @fileoverview Rule to check if a call to map should be a call to times
 */
'use strict';

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

module.exports = function (context) {
    var _require = require('../util/lodashUtil');

    var isCallToMethod = _require.isCallToMethod;
    var isLodashCall = _require.isLodashCall;
    var isLodashWrapper = _require.isLodashWrapper;

    var _map = ['flatMap', 'cond', 'matches', 'property', 'last', 'findLast', 'includes', 'set'].map(function (m) {
        return require('lodash/' + m);
    });

    var _map2 = _slicedToArray(_map, 8);

    var flatMap = _map2[0];
    var cond = _map2[1];
    var matches = _map2[2];
    var property = _map2[3];
    var last = _map2[4];
    var findLast = _map2[5];
    var includes = _map2[6];
    var set = _map2[7];

    var callStack = [];
    var settings = require('../util/settingsUtil').getSettings(context);

    function getObjectPatternProperties(node) {
        return flatMap(node.properties, function (prop) {
            if (prop.shorthand) {
                return prop.key.name;
            }
            if (prop.value.type === 'Identifier') {
                return prop.value.name;
            }
            return getObjectPatternProperties(prop.value);
        });
    }

    var getParamNames = cond([[matches({ type: 'Identifier' }), property('name')], [matches({ type: 'ObjectPattern' }), getObjectPatternProperties]]);

    function handleFunctionExpression(node) {
        if (isCallToMethod(node.parent, settings.version, 'map') && (isLodashCall(node.parent, settings.pragma) || isLodashWrapper(node.parent, settings.pragma, settings.version))) {
            callStack.push({ func: node, params: flatMap(node.params, getParamNames), anyUsed: false });
        }
    }

    function handleExitFunctionExpression(node) {
        var state = last(callStack);
        if (state && state.func === node) {
            callStack.pop();
            if (!state.anyUsed) {
                context.report(node.parent, 'Prefer _.times over _.map without using arguments');
            }
        }
    }

    var isIterateeParamDefinition = function isIterateeParamDefinition(state, node) {
        return state && (node.parent === state.func && includes(state.func.params, node) || node.parent.type === 'AssignmentPattern' && node.parent.parent === state.func);
    };

    return {
        FunctionExpression: handleFunctionExpression,
        ArrowFunctionExpression: handleFunctionExpression,
        Identifier: function Identifier(node) {
            if (!isIterateeParamDefinition(last(callStack), node)) {
                var usageContext = findLast(callStack, function (state) {
                    return includes(state.params, node.name);
                });
                set(usageContext, 'anyUsed', true);
            }
        },

        'FunctionExpression:exit': handleExitFunctionExpression,
        'ArrowFunctionExpression:exit': handleExitFunctionExpression
    };
};