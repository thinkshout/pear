/**
 * @fileoverview Rule to check if there's a method in the chain start that can be in the chain
 */
'use strict';

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

module.exports = function (context) {
    var _require = require('../util/lodashUtil');

    var isLodashCall = _require.isLodashCall;
    var isLodashWrapper = _require.isLodashWrapper;
    var isNativeCollectionMethodCall = _require.isNativeCollectionMethodCall;

    var _require2 = require('../util/astUtil');

    var getMethodName = _require2.getMethodName;
    var getCaller = _require2.getCaller;

    var settings = require('../util/settingsUtil').getSettings(context);

    var _map = ['get', 'includes', 'cond', 'matches', 'property', 'some', 'map'].map(function (m) {
        return require('lodash/' + m);
    });

    var _map2 = _slicedToArray(_map, 7);

    var get = _map2[0];
    var includes = _map2[1];
    var cond = _map2[2];
    var matches = _map2[3];
    var property = _map2[4];
    var some = _map2[5];
    var map = _map2[6];

    var REPORT_MESSAGE = 'Prefer \'_.{{method}}\' over the native function.';
    var exceptions = get(context, ['options', 0, 'except'], []);
    var ignoredObjects = get(context, ['options', 0, 'ignoreObjects'], []);
    var ignoredPatterns = map(get(context, ['options', 0, 'ignorePatterns'], []), function (pattern) {
        return new RegExp(pattern);
    });

    function isNonNullObjectCreate(callerName, methodName, arg) {
        return callerName === 'Object' && methodName === 'create' && get(arg, 'value') !== null;
    }

    function isStaticNativeMethodCall(node) {
        var staticMethods = {
            Object: ['assign', 'keys', 'values'],
            Array: ['isArray']
        };
        var callerName = get(node, 'callee.object.name');
        var methodName = getMethodName(node);
        return callerName in staticMethods && includes(staticMethods[callerName], methodName) || isNonNullObjectCreate(callerName, methodName, node.arguments[0]);
    }

    function isUsingLodash(node) {
        return isLodashCall(node, settings.pragma) || isLodashWrapper(getCaller(node), settings.pragma, settings.version);
    }

    function canUseLodash(node) {
        return isNativeCollectionMethodCall(node) || isStaticNativeMethodCall(node);
    }

    var getTextOfNode = cond([[matches({ type: 'Identifier' }), property('name')], [property('type'), function (node) {
        return context.getSourceCode().getText(node);
    }]]);

    function isIgnoredObject(node) {
        var callerName = getTextOfNode(getCaller(node));
        if (!callerName) {
            return false;
        }

        if (includes(ignoredObjects, callerName)) {
            return true;
        }

        if (some(ignoredPatterns, function (pattern) {
            return callerName.match(pattern);
        })) {
            return true;
        }

        return false;
    }

    function isRuleException(node) {
        return includes(exceptions, getMethodName(node));
    }

    return {
        CallExpression: function CallExpression(node) {
            if (!isRuleException(node) && !isIgnoredObject(node) && canUseLodash(node) && !isUsingLodash(node)) {
                context.report(node, REPORT_MESSAGE, { method: getMethodName(node) });
            }
        }
    };
};

module.exports.schema = [{
    type: 'object',
    properties: {
        except: {
            type: 'array',
            items: {
                type: 'string'
            }
        },
        ignoreObjects: {
            type: 'array',
            items: {
                type: 'string'
            }
        },
        ignorePatterns: {
            type: 'array',
            items: {
                type: 'string'
            }
        }
    }
}];