/**
 * @fileoverview Rule to check that iteratees for all collection functions except forEach return a value;
 */
'use strict';

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

module.exports = function (context) {
    var _map = ['last', 'get'].map(function (m) {
        return require('lodash/' + m);
    });

    var _map2 = _slicedToArray(_map, 2);

    var last = _map2[0];
    var get = _map2[1];

    var _require = require('../util/astUtil');

    var getMethodName = _require.getMethodName;

    var _require2 = require('../util/lodashUtil');

    var isLodashCollectionMethod = _require2.isLodashCollectionMethod;
    var isLodashCall = _require2.isLodashCall;
    var isLodashWrapper = _require2.isLodashWrapper;

    var settings = require('../util/settingsUtil').getSettings(context);
    var callStack = [];

    function handleExitOfFunctionWithBlock(node) {
        var functionNode = callStack.pop();
        var lastItem = last(callStack);
        if (!functionNode.found && get(lastItem, 'node.type') === 'CallExpression') {
            context.report(node, 'Do not use _.' + getMethodName(lastItem.node) + ' without returning a value');
        }
        if (lastItem && lastItem.node === node.parent) {
            callStack.pop();
        }
    }
    function addToCallStackIfCollectionMethod(node) {
        if (isLodashCollectionMethod(node, settings.version) && (isLodashCall(node, settings.pragma) || isLodashWrapper(node, settings.pragma, settings.version))) {
            callStack.push({ node: node });
        }
    }

    return {
        FunctionExpression: function FunctionExpression(node) {
            addToCallStackIfCollectionMethod(node.parent);
            callStack.push({ node: node, found: false });
        },

        'FunctionExpression:exit': handleExitOfFunctionWithBlock,
        ArrowFunctionExpression: function ArrowFunctionExpression(node) {
            if (node.body.type === 'BlockStatement') {
                addToCallStackIfCollectionMethod(node.parent);
                callStack.push({ node: node, found: false });
            }
        },
        'ArrowFunctionExpression:exit': function ArrowFunctionExpressionExit(node) {
            if (node.body.type === 'BlockStatement') {
                handleExitOfFunctionWithBlock(node);
            }
        },
        ReturnStatement: function ReturnStatement() {
            var lastItem = last(callStack);
            if (lastItem) {
                lastItem.found = true;
            }
        }
    };
};