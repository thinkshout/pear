'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parseDocument;

var _babelTypes = require('babel-types');

var t = _interopRequireWildcard(_babelTypes);

var _language = require('graphql/language');

var _parseVariable = require('./parse-variable');

var _parseVariable2 = _interopRequireDefault(_parseVariable);

var _getSelections = require('./get-selections');

var _getSelections2 = _interopRequireDefault(_getSelections);

var _sortDefinitions = require('./sort-definitions');

var _sortDefinitions2 = _interopRequireDefault(_sortDefinitions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Goes through the document, parsing each OperationDefinition (i.e. query/mutation) and FragmentDefinition
// and returns the resulting query builder code
function parseDocument(document, documentId, parentScope) {
  var clientId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : t.identifier('client');

  var babelAstNodes = [];
  var spreadsId = void 0;

  document.definitions = (0, _sortDefinitions2.default)(document.definitions);

  // Create an empty object to store the spreads if the document has fragments
  if (document.definitions.length && document.definitions[0].kind === 'FragmentDefinition') {
    spreadsId = parentScope.generateUidIdentifier('spreads');

    babelAstNodes.push(t.variableDeclaration('const', [t.variableDeclarator(spreadsId, t.objectExpression([]))]));
  }

  (0, _language.visit)(document, {
    FragmentDefinition: function FragmentDefinition(node) {
      var parentSelections = ['root'];
      // Fragments are always named
      var args = [t.stringLiteral(node.name.value), t.stringLiteral(node.typeCondition.name.value)];

      args.push(t.arrowFunctionExpression([t.identifier('root')], t.blockStatement((0, _getSelections2.default)(node.selectionSet, parentSelections, spreadsId, clientId))));

      babelAstNodes.push(t.expressionStatement(t.assignmentExpression('=', t.memberExpression(spreadsId, t.identifier(node.name.value)), t.callExpression(t.memberExpression(documentId, t.identifier('defineFragment')), args))));
    },
    OperationDefinition: function OperationDefinition(node) {
      var parentSelections = ['root'];
      var args = [];

      if (node.name) {
        args.push(t.stringLiteral(node.name.value));
      }

      if (node.variableDefinitions && node.variableDefinitions.length) {
        var variables = [];

        node.variableDefinitions.forEach(function (variable) {
          variables.push((0, _parseVariable2.default)(variable, clientId));
        });

        args.push(t.arrayExpression(variables));
      }

      args.push(t.arrowFunctionExpression([t.identifier('root')], t.blockStatement((0, _getSelections2.default)(node.selectionSet, parentSelections, spreadsId, clientId))));

      var operationId = void 0;

      if (node.operation === 'query') {
        operationId = 'addQuery';
      } else {
        operationId = 'addMutation';
      }

      babelAstNodes.push(t.callExpression(t.memberExpression(documentId, t.identifier(operationId)), args));
    }
  });

  return babelAstNodes;
}